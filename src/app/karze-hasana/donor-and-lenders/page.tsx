import React, { Suspense, cache } from 'react'
import {
	Table,
	TableBody,
	TableCell,
	TableFooter,
	TableHead,
	TableHeader,
	TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button"
import Link from 'next/link';
import { Metadata } from 'next';
import FilterControlsDonor from '@/components/FilterControlsDonor';
import { DonorIProps, DonorPaymentIProps } from '@/types';
import { FilterSkeleton } from '@/components/FilterSkeleton';
import Pagination from '@/components/beneficial-pagination';
import { getDonorData } from '@/lib/SearchDonor';

export const metadata: Metadata = {
	title: "Donor List",
	description: "Generated by Rakibul hasan",
};

// Add this to make the page dynamic
export const dynamic = 'force-dynamic';

interface PageProps {
	searchParams?: {
		search?: string;
		page?: string;
	};
}

interface DonorCalculations {
	totalAmount: number;
	returnedAmount: string;
	status: string;
}

// Cache the donor payment fetch with React cache
const getDonorPayments = cache(async (username: string): Promise<DonorPaymentIProps[]> => {
	try {
		const response = await fetch(`https://af-admin.vercel.app/api/donor_payment/${username}`, {
			next: {
				revalidate: 0, // Cache for 5 minutes
				tags: [`donor-payments-${username}`] // Add cache tags for selective revalidation
			}
		});

		if (!response.ok) {
			console.error(`HTTP error for ${username}! status: ${response.status}`);
			return [];
		}

		const data = await response.json();
		return data.data || [];
	} catch (error) {
		console.error(`Failed to fetch donor payments for ${username}:`, error);
		return [];
	}
});

// Optimized server-side calculation function
const calculateDonorAmounts = cache(async (status: string, username: string): Promise<DonorCalculations> => {
	const paymentList = await getDonorPayments(username);

	// Single pass calculation for all values
	const calculations = paymentList.reduce(
		(acc, item) => {
			// Calculate lending total
			if (item.type === "LENDING" && item.amount) {
				acc.lendingTotal += Number(item.amount) || 0;
			}
			// Calculate donate total
			if (item.type === "DONATE" && item.donate) {
				acc.donateTotal += Number(item.donate) || 0;
			}
			// Calculate loan payment total (only for LEADER status)
			if (status === "LEADER" && item.loanPayment) {
				acc.loanPaymentTotal += Number(item.loanPayment) || 0;
			}
			return acc;
		},
		{ lendingTotal: 0, donateTotal: 0, loanPaymentTotal: 0 }
	);

	const totalAmount = status === "LEADER"
		? calculations.lendingTotal
		: calculations.lendingTotal + calculations.donateTotal;

	const returnedAmount = status === "LEADER"
		? calculations.loanPaymentTotal.toString()
		: 'N/A';

	const displayStatus = status === "LEADER" ? "LENDER" : status;

	return {
		totalAmount,
		returnedAmount,
		status: displayStatus
	};
});

// Optimized server component for individual donor row
async function DonorRow({ item, index }: { item: DonorIProps; index: number }) {
	const calculations = await calculateDonorAmounts(item.status, item.username);

	return (
		<TableRow>
			<TableCell className="font-medium">{item.code}</TableCell>
			<TableCell className="font-medium uppercase">{item.name}</TableCell>
			<TableCell className="font-medium uppercase">
				{calculations.totalAmount.toLocaleString()}
			</TableCell>
			<TableCell className="font-medium uppercase">
				{calculations.returnedAmount === 'N/A'
					? calculations.returnedAmount
					: Number(calculations.returnedAmount).toLocaleString()
				}
			</TableCell>
			<TableCell className="font-medium uppercase">
				{calculations.status}
			</TableCell>
			<TableCell className="font-medium uppercase">
				<Button className='bg-color-sub' size={"sm"} asChild>
					<Link prefetch={false} href={`donor-and-lenders/${item.username}`}>DETAILS</Link>
				</Button>
			</TableCell>
		</TableRow>
	);
}

// Batch process donors for better performance
async function DonorList({ searchParams }: PageProps) {
	try {
		const { data: donors } = await getDonorData(searchParams || {});

		// Process donors in parallel batches to avoid overwhelming the API
		const batchSize = 5;
		const donorBatches = [];

		for (let i = 0; i < donors.length; i += batchSize) {
			donorBatches.push(donors.slice(i, i + batchSize));
		}

		return (
			<TableBody>
				{donorBatches.map((batch, batchIndex) =>
					batch.map((item: DonorIProps, index: number) => (
						<Suspense
							key={`donor-${item.username}`}
							fallback={<DonorRowSkeleton />}
						>
							<DonorRow
								item={item}
								index={batchIndex * batchSize + index}
							/>
						</Suspense>
					))
				)}
			</TableBody>
		);
	} catch (error) {
		console.error('DonorList error:', error);
		throw new Error("Data fetch failed");
	}
}

// Skeleton component for individual donor rows
function DonorRowSkeleton() {
	return (
		<TableRow>
			<TableCell><div className="h-4 bg-gray-200 animate-pulse rounded w-16" /></TableCell>
			<TableCell><div className="h-4 bg-gray-200 animate-pulse rounded w-32" /></TableCell>
			<TableCell><div className="h-4 bg-gray-200 animate-pulse rounded w-20" /></TableCell>
			<TableCell><div className="h-4 bg-gray-200 animate-pulse rounded w-20" /></TableCell>
			<TableCell><div className="h-4 bg-gray-200 animate-pulse rounded w-16" /></TableCell>
			<TableCell><div className="h-6 bg-gray-200 animate-pulse rounded w-20" /></TableCell>
		</TableRow>
	);
}

// Complete table skeleton for better UX
function TableLoadingFallback() {
	return (
		<TableBody>
			{Array.from({ length: 10 }).map((_, i) => (
				<DonorRowSkeleton key={`skeleton-${i}`} />
			))}
		</TableBody>
	);
}

// Pre-fetch and cache donor calculations for better performance
async function preloadDonorCalculations(donors: DonorIProps[]) {
	// Pre-warm the cache by batching requests
	const promises = donors.map(donor =>
		calculateDonorAmounts(donor.status, donor.username).catch(() => null)
	);

	// Process in smaller batches to avoid overwhelming the API
	const batchSize = 10;
	for (let i = 0; i < promises.length; i += batchSize) {
		const batch = promises.slice(i, i + batchSize);
		await Promise.allSettled(batch);

		// Small delay between batches to be nice to the API
		if (i + batchSize < promises.length) {
			await new Promise(resolve => setTimeout(resolve, 50));
		}
	}
}

export default async function DonorListPage({ searchParams }: PageProps) {
	try {
		// Await the searchParams to handle the Promise properly
		const resolvedSearchParams = await searchParams;

		// Fetch pagination data and donor list in parallel
		const [{ pagination }, { data: donors }] = await Promise.all([
			getDonorData(resolvedSearchParams || {}),
			getDonorData(resolvedSearchParams || {})
		]);

		// Pre-load calculations in the background (don't await to avoid blocking render)
		preloadDonorCalculations(donors).catch(console.error);

		return (
			<div className='flex flex-col'>
				<Suspense fallback={<FilterSkeleton />}>
					<FilterControlsDonor />
				</Suspense>

				<Table>
					<TableHeader>
						<TableRow>
							<TableHead>INDEX</TableHead>
							<TableHead className='w-[300px]'>NAME</TableHead>
							<TableHead>AMOUNT</TableHead>
							<TableHead>RETURNED AMOUNT</TableHead>
							<TableHead>TYPE</TableHead>
							<TableHead>DETAILS</TableHead>
						</TableRow>
					</TableHeader>

					<Suspense fallback={<TableLoadingFallback />}>
						<DonorList searchParams={resolvedSearchParams} />
					</Suspense>

					<TableFooter>
						<TableRow>
							<TableHead colSpan={6}>
								<Pagination
									currentPage={pagination.currentPage}
									totalPages={pagination.totalPages}
									hasNext={pagination.hasNext}
									hasPrev={pagination.hasPrev}
								/>
							</TableHead>
						</TableRow>
					</TableFooter>
				</Table>
			</div>
		);
	} catch (error) {
		console.error('Page error:', error);
		throw new Error("Data fetch Error Page Number");
	}
}	