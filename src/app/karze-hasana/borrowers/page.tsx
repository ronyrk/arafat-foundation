import React, { Suspense } from 'react'
import {
	Table,
	TableBody,
	TableCell,
	TableFooter,
	TableHead,
	TableHeader,
	TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button"
import Link from 'next/link';
import { LoanIProps, PaymentIProps } from '@/types';
import { unstable_noStore } from 'next/cache';
import { Metadata } from 'next';
import { getBorrowerSearchData } from '@/lib/SearchBorrowers';
import PaginationPart from '@/components/Pagination';
import FilterControlsDonor from '@/components/FilterControlsDonor';
import { FilterSkeleton } from '@/components/FilterSkeleton';
import Pagination from '@/components/beneficial-pagination';

export const dynamic = 'force-dynamic'

export const metadata: Metadata = {
	title: "Borrowers List",
	description: "Generated by Rakibul hasan",
};

interface PageProps {
	searchParams?: {
		search?: string;
		page?: string;
	};
}

// Helper interface for borrower with calculated values
interface BorrowerWithCalculations {
	username: string;
	name: string;
	balance: string;
	totalDisbursed: number;
	totalPayment: number;
	duePayment: number;
}

// Optimized payment data fetching with better error handling and timeout
async function fetchPaymentData(username: string): Promise<PaymentIProps[]> {
	unstable_noStore();

	const controller = new AbortController();
	const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

	try {
		const response = await fetch(`https://af-admin.vercel.app/api/loan_list/${username}`, {
			signal: controller.signal,
			headers: {
				'Cache-Control': 'no-cache',
			}
		});

		clearTimeout(timeoutId);

		if (!response.ok) {
			console.error(`Failed to fetch payment data for ${username}:`, response.statusText);
			return [];
		}

		const paymentList: PaymentIProps[] = await response.json();
		return Array.isArray(paymentList) ? paymentList : [];
	} catch (error) {
		clearTimeout(timeoutId);
		if (error instanceof Error && error.name === 'AbortError') {
			console.error(`Timeout fetching payment data for ${username}`);
		} else {
			console.error(`Error fetching payment data for ${username}:`, error);
		}
		return [];
	}
}

// Optimized calculation function with better number parsing
async function calculateBorrowerData(borrower: LoanIProps): Promise<BorrowerWithCalculations> {
	const paymentList = await fetchPaymentData(borrower.username);

	// Parse balance safely
	const balance = parseFloat(borrower.balance?.replace(/[^\d.-]/g, '') || '0') || 0;

	const totalDisbursed = paymentList.reduce((total, item) => {
		const loanAmount = parseFloat(String(item.loanAmount)?.replace(/[^\d.-]/g, '') || '0') || 0;
		return total + loanAmount;
	}, balance);

	const totalPayment = paymentList.reduce((total, item) => {
		const amount = parseFloat(String(item.amount)?.replace(/[^\d.-]/g, '') || '0') || 0;
		return total + amount;
	}, 0);

	const duePayment = Math.max(totalDisbursed - totalPayment, 0);

	return {
		username: borrower.username,
		name: borrower.name,
		balance: borrower.balance,
		totalDisbursed,
		totalPayment,
		duePayment
	};
}

// Batch processing for better performance
async function processBorrowersInBatches(
	borrowers: LoanIProps[],
	batchSize: number = 3
): Promise<BorrowerWithCalculations[]> {
	const results: BorrowerWithCalculations[] = [];

	for (let i = 0; i < borrowers.length; i += batchSize) {
		const batch = borrowers.slice(i, i + batchSize);
		try {
			const batchResults = await Promise.all(
				batch.map(borrower => calculateBorrowerData(borrower))
			);
			results.push(...batchResults);
		} catch (error) {
			console.error(`Error processing batch ${i}-${i + batchSize}:`, error);
			// Add fallback data for failed batch
			const fallbackData = batch.map(borrower => ({
				username: borrower.username,
				name: borrower.name,
				balance: borrower.balance,
				totalDisbursed: parseFloat(borrower.balance?.replace(/[^\d.-]/g, '') || '0') || 0,
				totalPayment: 0,
				duePayment: parseFloat(borrower.balance?.replace(/[^\d.-]/g, '') || '0') || 0
			}));
			results.push(...fallbackData);
		}
	}

	return results;
}

async function BorrowersList({ searchParams }: PageProps) {
	try {
		const { data: borrowers, pagination } = await getBorrowerSearchData(searchParams || {});

		if (!borrowers || borrowers.length === 0) {
			return (
				<TableBody>
					<TableRow>
						<TableCell colSpan={6} className="text-center py-8">
							No borrowers found.
						</TableCell>
					</TableRow>
				</TableBody>
			);
		}

		// Process borrowers in batches for better performance
		const borrowersWithCalculations = await processBorrowersInBatches(borrowers);

		const currentPage = Number(searchParams?.page || '1');
		const pageSize = 10;

		return (
			<TableBody>
				{borrowersWithCalculations.map((item, index: number) => {
					const actualIndex = (currentPage - 1) * pageSize + index + 1;

					return (
						<TableRow key={item.username}>
							<TableCell className="font-medium">{actualIndex}</TableCell>
							<TableCell className="font-medium uppercase">{item.name}</TableCell>
							<TableCell className="font-medium">
								{item.totalDisbursed.toLocaleString('en-BD', {
									style: 'currency',
									currency: 'BDT',
									minimumFractionDigits: 0
								})}
							</TableCell>
							<TableCell className="font-medium">
								{item.totalPayment.toLocaleString('en-BD', {
									style: 'currency',
									currency: 'BDT',
									minimumFractionDigits: 0
								})}
							</TableCell>
							<TableCell className="font-medium">
								{item.duePayment.toLocaleString('en-BD', {
									style: 'currency',
									currency: 'BDT',
									minimumFractionDigits: 0
								})}
							</TableCell>
							<TableCell className="font-medium">
								<Button className='bg-color-sub' size={"sm"} asChild>
									<Link href={`borrowers/${item.username}`}>Details</Link>
								</Button>
							</TableCell>
						</TableRow>
					);
				})}
			</TableBody>
		)
	} catch (error) {
		console.error('Error loading borrowers list:', error);
		return (
			<TableBody>
				<TableRow>
					<TableCell colSpan={6} className="text-center text-red-500 py-8">
						Failed to load data. Please try again later.
					</TableCell>
				</TableRow>
			</TableBody>
		);
	}
}

// Memoized filter controls wrapper
const FilterControlsWrapper = React.memo(function FilterControlsWrapper() {
	return <FilterControlsDonor />;
});

async function page({ searchParams }: PageProps) {
	try {
		const { data, pagination } = await getBorrowerSearchData(searchParams || {});

		return (
			<div className='flex flex-col'>
				<Suspense fallback={<FilterSkeleton />}>
					<FilterControlsWrapper />
				</Suspense>

				<div className="rounded-md border">
					<Table>
						<TableHeader>
							<TableRow>
								<TableHead>INDEX</TableHead>
								<TableHead className='w-[300px]'>BORROWERS NAME</TableHead>
								<TableHead>DISBURSED</TableHead>
								<TableHead>RECOVERED</TableHead>
								<TableHead>BALANCE</TableHead>
								<TableHead>DETAILS</TableHead>
							</TableRow>
						</TableHeader>
						<Suspense fallback={
							<TableBody>
								<TableRow>
									<TableCell colSpan={6} className="text-center p-4">
										Loading borrowers data...
									</TableCell>
								</TableRow>
							</TableBody>
						}>
							<BorrowersList searchParams={searchParams} />
						</Suspense>
						<TableFooter>
							<TableRow>
								<TableHead colSpan={6}>
									<Pagination
										currentPage={pagination.currentPage}
										totalPages={pagination.totalPages}
										hasNext={pagination.hasNext}
										hasPrev={pagination.hasPrev}
									/>
								</TableHead>
							</TableRow>
						</TableFooter>
					</Table>
				</div>
			</div>
		)
	} catch (error) {
		console.error('Error loading page:', error);
		return (
			<div className="text-center text-red-500 p-8">
				Failed to load data. Please try again later.
			</div>
		);
	}
}

export default page